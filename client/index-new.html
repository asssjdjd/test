<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Controller - NEW</title>
    <style>
        body { font-family: sans-serif; display: grid; place-items: center; min-height: 90vh; background: #111; color: white; }
        #connect-ui { text-align: center; }
        #streaming-ui { display: none; } 
        video {
            width: 80vw;
            height: auto;
            background: #333;
            border: 2px solid #555;
            cursor: crosshair;
            outline: none;
        }
        video:focus {
            border-color: #0080ff;
            box-shadow: 0 0 10px rgba(0,128,255,0.5);
        }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        input { padding: 10px; font-size: 16px; width: 300px; }
    </style>
</head>
<body>
    <div id="connect-ui">
        <h1>üéÆ K·∫øt n·ªëi t·ªõi Host</h1>
        <p>Nh·∫≠p ID c·ªßa m√°y Host:</p>
        <input type="text" id="hostIdInput" placeholder="abc123xyz" />
        <button id="connectBtn">K·∫øt n·ªëi</button>
        <p id="status" style="color: yellow;"></p>
    </div>

    <div id="streaming-ui">
        <video id="remoteVideo" autoplay playsinline></video>
        <p style="color: lime; position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); padding: 10px;">
            ‚úÖ ƒêang streaming t·ª´ host
        </p>
    </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    
    <script>
        console.log('=== CLIENT SCRIPT START ===');
        
        const connectUI = document.getElementById('connect-ui');
        const streamingUI = document.getElementById('streaming-ui');
        const hostIdInput = document.getElementById('hostIdInput');
        const connectBtn = document.getElementById('connectBtn');
        const statusEl = document.getElementById('status');
        const remoteVideo = document.getElementById('remoteVideo');
        
        const SIGNALING_SERVER_URL = 'https://pasty-unscarce-magnanimously.ngrok-free.dev/';
        let pc, socket;
        
        const iceServersConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'turn:a.relay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' }
            ]
        };
        
        socket = io(SIGNALING_SERVER_URL, { transports: ['websocket'] });
        
        socket.on('connect', () => {
            statusEl.textContent = 'S·∫µn s√†ng - ID: ' + socket.id;
            console.log('[Client] Connected:', socket.id);
        });
        
        socket.on('connect_error', (err) => {
            statusEl.textContent = 'L·ªói: ' + err.message;
            console.error('[Client] Error:', err);
        });
        
        connectBtn.onclick = async () => {
            const hostId = hostIdInput.value.trim();
            if (!hostId) {
                alert('Nh·∫≠p Host ID!');
                return;
            }
            
            statusEl.textContent = 'ƒêang k·∫øt n·ªëi...';
            console.log('[Client] Connecting to host:', hostId);
            
            pc = new RTCPeerConnection(iceServersConfig);
            
            // === ADD TRANSCEIVER TO RECEIVE VIDEO ===
            console.log('[Client] *** ADDING TRANSCEIVER ***');
            pc.addTransceiver('video', { direction: 'recvonly' });
            
            // === ONTRACK - QUAN TR·ªåNG NH·∫§T ===
            console.log('[Client] *** SETTING UP ONTRACK ***');
            pc.ontrack = (event) => {
                console.log('[Client] ========== ONTRACK FIRED ==========');
                console.log('[Client] Event:', event);
                console.log('[Client] Streams:', event.streams);
                console.log('[Client] Track:', event.track);
                
                if (!event.streams || event.streams.length === 0) {
                    console.error('[Client] ‚ùå No streams!');
                    return;
                }
                
                const stream = event.streams[0];
                console.log('[Client] ‚úÖ Got stream with', stream.getTracks().length, 'tracks');
                
                remoteVideo.srcObject = stream;
                connectUI.style.display = 'none';
                streamingUI.style.display = 'block';
                
                remoteVideo.play().then(() => {
                    console.log('[Client] ‚úÖ Video playing!');
                    statusEl.textContent = '‚úÖ Streaming!';
                }).catch(err => {
                    console.error('[Client] ‚ùå Play error:', err);
                });
            };
            
            pc.oniceconnectionstatechange = () => {
                console.log('[Client] ICE state:', pc.iceConnectionState);
                if (pc.iceConnectionState === 'connected') {
                    statusEl.textContent = 'WebRTC connected!';
                }
            };
            
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('candidate', event.candidate, hostId);
                }
            };
            
            // Create data channel
            const dc = pc.createDataChannel('control', {
                ordered: false,
                maxRetransmits: 0
            });
            
            // === EVENT HANDLER SETUP ===
            dc.onopen = () => {
                console.log('[Client] ‚úÖ Data channel opened!');
                setupRemoteControl(remoteVideo, dc);
            };
            
            dc.onclose = () => {
                console.log('[Client] ‚ùå Data channel closed');
            };
            
            dc.onerror = (err) => {
                console.error('[Client] Data channel error:', err);
            };
            
            // Handle answer
            socket.on('answer', async (answer) => {
                console.log('[Client] Got answer');
                await pc.setRemoteDescription(new RTCSessionDescription(answer));
            });
            
            // Handle candidates
            socket.on('candidate', (candidate) => {
                pc.addIceCandidate(new RTCIceCandidate(candidate));
            });
            
            // Create and send offer
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit('offer', offer, hostId, socket.id);
            
            console.log('[Client] Offer sent to:', hostId);
        };
        
        // ========================================
        // EVENT HANDLERS - REMOTE CONTROL LOGIC
        // ========================================
        
        let lastMoveTime = 0;
        const MOVE_THROTTLE_MS = 50;
        let scrollTimeout;
        let accumulatedDeltaY = 0;
        const SCROLL_DEBOUNCE_MS = 100;
        let eventQueue = [];
        let batchTimeout;
        const BATCH_INTERVAL_MS = 20;
        let activeDataChannel = null;
        
        function sendCommand(payload) {
            if (!activeDataChannel || activeDataChannel.readyState !== 'open') {
                console.warn('[Client] Cannot send - data channel not open');
                return;
            }
            
            // LOW PRIORITY - batch mouse/scroll
            if (payload.type === 'mousemove' || payload.type === 'scroll') {
                const lastEventIndex = eventQueue.findLastIndex(e => e.type === payload.type);
                
                if (lastEventIndex !== -1) {
                    eventQueue[lastEventIndex] = payload;
                } else {
                    eventQueue.push(payload);
                }
                
                clearTimeout(batchTimeout);
                batchTimeout = setTimeout(flushLowPriorityQueue, BATCH_INTERVAL_MS);
                
            } else {
                // HIGH PRIORITY - send immediately
                flushLowPriorityQueue();
                
                const batch = [payload];
                activeDataChannel.send(JSON.stringify(batch));
                console.log('[Client] Sent critical:', payload.type);
            }
        }
        
        function flushLowPriorityQueue() {
            if (eventQueue.length === 0) return;
            
            if (activeDataChannel && activeDataChannel.readyState === 'open') {
                const batch = [...eventQueue];
                eventQueue = [];
                activeDataChannel.send(JSON.stringify(batch));
            }
        }
        
        function getScaledCoordinates(e, videoEl) {
            const rect = videoEl.getBoundingClientRect();
            const videoWidth = videoEl.videoWidth;
            const videoHeight = videoEl.videoHeight;
            
            const actualWidth = videoWidth > 0 ? videoWidth : rect.width;
            const actualHeight = videoHeight > 0 ? videoHeight : rect.height;
            
            const scaleX = actualWidth / rect.width;
            const scaleY = actualHeight / rect.height;
            
            return {
                x: Math.round((e.clientX - rect.left) * scaleX),
                y: Math.round((e.clientY - rect.top) * scaleY)
            };
        }
        
        function handleMouseMove(e) {
            const currentTime = Date.now();
            if (currentTime - lastMoveTime < MOVE_THROTTLE_MS) return;
            lastMoveTime = currentTime;
            
            const coords = getScaledCoordinates(e, this);
            if (!coords) return;
            
            sendCommand({
                type: "mousemove",
                x: coords.x,
                y: coords.y
            });
        }
        
        function handleWheel(e) {
            e.preventDefault();
            accumulatedDeltaY += e.deltaY;
            clearTimeout(scrollTimeout);
            
            scrollTimeout = setTimeout(() => {
                sendCommand({
                    type: "scroll",
                    deltaY: accumulatedDeltaY
                });
                accumulatedDeltaY = 0;
            }, SCROLL_DEBOUNCE_MS);
        }
        
        function handleMouseDown(e) {
            e.preventDefault();
            const button = e.button === 2 ? "right" : e.button === 1 ? "middle" : "left";
            const coords = getScaledCoordinates(e, this);
            if (!coords) return;
            
            sendCommand({ type: "down", button, x: coords.x, y: coords.y });
        }
        
        function handleMouseUp(e) {
            e.preventDefault();
            const button = e.button === 2 ? "right" : e.button === 1 ? "middle" : "left";
            const coords = getScaledCoordinates(e, this);
            if (!coords) return;
            
            sendCommand({ type: "up", button, x: coords.x, y: coords.y });
        }
        
        function handleContextMenu(e) {
            e.preventDefault();
        }
        
        function handleKeyDown(e) {
            e.preventDefault();
            if (e.repeat) return;
            
            sendCommand({
                type: "keydown",
                key: e.key,
                code: e.code,
                ctrlKey: e.ctrlKey,
                shiftKey: e.shiftKey,
                altKey: e.altKey,
                metaKey: e.metaKey,
            });
        }
        
        function handleKeyUp(e) {
            e.preventDefault();
            sendCommand({ type: "keyup", key: e.key, code: e.code });
        }
        
        function handleFocus() {
            this.style.borderColor = "blue";
            console.log('[Client] Video focused - controls active');
        }
        
        function handleBlur() {
            this.style.borderColor = "#555";
            console.log('[Client] Video blurred - controls inactive');
        }
        
        function setupRemoteControl(videoElement, dataChannel) {
            activeDataChannel = dataChannel;
            
            videoElement.setAttribute('tabindex', '0');
            
            videoElement.addEventListener('mousemove', handleMouseMove);
            videoElement.addEventListener('wheel', handleWheel);
            videoElement.addEventListener('mousedown', handleMouseDown);
            videoElement.addEventListener('mouseup', handleMouseUp);
            videoElement.addEventListener('contextmenu', handleContextMenu);
            videoElement.addEventListener('keydown', handleKeyDown);
            videoElement.addEventListener('keyup', handleKeyUp);
            videoElement.addEventListener('focus', handleFocus);
            videoElement.addEventListener('blur', handleBlur);
            
            console.log('[Client] ‚úÖ Remote control events attached to video');
            
            // Auto focus
            setTimeout(() => {
                videoElement.focus();
                console.log('[Client] Auto-focused video element');
            }, 500);
        }
        
        console.log('=== CLIENT SCRIPT READY ===');
    </script>
</body>
</html>
